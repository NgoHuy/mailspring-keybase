'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = multiReplaceStatement;

var _copyComments = require('./copyComments');

var _copyComments2 = _interopRequireDefault(_copyComments);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Replaces `node` inside `parent` with any number of `replacements`.
 *
 * ESTraverse only allows replacing one node with a single other node.
 * This function overcomes this limitation, allowing to replace it with multiple nodes.
 *
 * NOTE: Only works for nodes that allow multiple elements in their body.
 *       When node doesn't exist inside parent, does nothing.
 *
 * @param  {Object} cfg
 *   @param  {Object} cfg.parent Parent node of the node to replace
 *   @param  {Object} cfg.node The node to replace
 *   @param  {Object[]} cfg.replacements Replacement nodes (can be empty array)
 *   @param  {Boolean} [cfg.preserveComments] True to copy over comments from
 *     node to first replacement node
 */
function multiReplaceStatement(_ref) {
  var parent = _ref.parent,
      node = _ref.node,
      replacements = _ref.replacements,
      preserveComments = _ref.preserveComments;

  var body = getBody(parent);
  var index = body.indexOf(node);
  if (preserveComments && replacements[0]) {
    (0, _copyComments2.default)({ from: node, to: replacements[0] });
  }
  if (index !== -1) {
    body.splice.apply(body, [index, 1].concat(_toConsumableArray(replacements)));
  }
}

function getBody(node) {
  switch (node.type) {
    case 'BlockStatement':
    case 'Program':
      return node.body;
    case 'SwitchCase':
      return node.consequent;
    default:
      throw 'Unsupported node type \'' + node.type + '\' in multiReplaceStatement()';
  }
}