'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, logger) {
  var hierarchy = new _Hierarchy2.default(ast);

  _traverser2.default.traverse(ast, (0, _withScope2.default)(ast, {
    enter: function enter(fnNode, parent, scope) {
      if (functionType.isFunction(fnNode)) {
        scope.variables.filter(isParameter).map(function (v) {
          return { variable: v, exs: getMemberExpressions(v, hierarchy) };
        }).filter(function (_ref) {
          var exs = _ref.exs;
          return exs.length > 0;
        }).forEach(function (_ref2) {
          var variable = _ref2.variable,
              exs = _ref2.exs;

          // Replace parameter with destruct-pattern
          var index = fnNode.params.findIndex(function (param) {
            return param === variable.defs[0].name;
          });
          if (index === -1) {
            return;
          }

          if (uniqPropNames(exs).length > MAX_PROPS) {
            logger.warn(fnNode, uniqPropNames(exs).length + ' different props found, will not transform more than ' + MAX_PROPS, 'destruct-param');
            return;
          }

          fnNode.params[index] = createDestructPattern(exs);

          // Replace references of obj.foo with simply foo
          exs.forEach(function (ex) {
            ex.type = ex.property.type;
            ex.name = ex.property.name;
          });
        });
      }
    }
  }));
};

var _fp = require('lodash/fp');

var _recast = require('recast');

var _recast2 = _interopRequireDefault(_recast);

var _Parser = require('../Parser');

var _Parser2 = _interopRequireDefault(_Parser);

var _traverser = require('../traverser');

var _traverser2 = _interopRequireDefault(_traverser);

var _withScope = require('../withScope');

var _withScope2 = _interopRequireDefault(_withScope);

var _functionType = require('../utils/functionType');

var functionType = _interopRequireWildcard(_functionType);

var _Hierarchy = require('../utils/Hierarchy');

var _Hierarchy2 = _interopRequireDefault(_Hierarchy);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MAX_PROPS = 4;

function isParameter(variable) {
  return variable.defs.length === 1 && variable.defs[0].type === 'Parameter';
}

function getMemberExpressions(variable, hierarchy) {
  var memberExpressions = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = variable.references[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var ref = _step.value;

      var memEx = hierarchy.getParent(ref.identifier);
      if (!isMemberExpressionObject(memEx, ref.identifier)) {
        return [];
      }

      var ex = hierarchy.getParent(memEx);
      if (isAssignment(ex, memEx) || isUpdate(ex, memEx) || isMethodCall(ex, memEx)) {
        return [];
      }

      if (isKeyword(memEx.property.name) || variableExists(memEx.property.name, ref.from)) {
        return [];
      }

      memberExpressions.push(memEx);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return memberExpressions;
}

function isMemberExpressionObject(memEx, object) {
  return memEx.type === 'MemberExpression' && memEx.object === object && memEx.computed === false;
}

function isAssignment(ex, node) {
  return ex.type === 'AssignmentExpression' && ex.left === node;
}

function isUpdate(ex, node) {
  return ex.type === 'UpdateExpression' && ex.argument === node;
}

function isMethodCall(ex, node) {
  return ex.type === 'CallExpression' && ex.callee === node;
}

function variableExists(variableName, scope) {
  while (scope) {
    if (scope.through.some(function (ref) {
      return ref.identifier.name === variableName;
    })) {
      return true;
    }
    if (scope.set.get(variableName)) {
      return true;
    }
    scope = scope.upper;
  }
  return false;
}

function isKeyword(name) {
  return _Parser2.default.tokenize(name)[0].type === 'Keyword';
}

function uniqPropNames(exs) {
  return (0, _fp.uniq)(exs.map(function (_ref3) {
    var property = _ref3.property;
    return property.name;
  }));
}

// By default recast indents the ObjectPattern AST node
// See: https://github.com/benjamn/recast/issues/240
//
// To work around this, we're building the desired string by ourselves,
// and parsing it with Recast and extracting the ObjectPatter node.
// Feeding this back to Recast will preserve the formatting.
function createDestructPattern(exs) {
  var props = uniqPropNames(exs).join(', ');
  var js = 'function foo({' + props + '}) {};';
  var ast = _recast2.default.parse(js, { parser: _Parser2.default });
  return ast.program.body[0].params[0];
}