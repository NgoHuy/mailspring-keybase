'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (ast, logger) {
  var potentialClasses = {};
  var inheritance = new _Inheritance2.default();

  _traverser2.default.traverse(ast, {
    enter: function enter(node, parent) {
      var m = void 0;

      if (m = (0, _matchFunctionDeclaration2.default)(node) || (0, _matchFunctionVar2.default)(node)) {
        potentialClasses[m.className] = new _PotentialClass2.default({
          name: m.className,
          fullNode: node,
          commentNodes: [node],
          parent: parent
        });
        potentialClasses[m.className].setConstructor(new _PotentialConstructor2.default({
          methodNode: m.constructorNode,
          potentialClass: potentialClasses[m.className]
        }));
      } else if (m = (0, _matchFunctionAssignment2.default)(node)) {
        if (potentialClasses[m.className]) {
          potentialClasses[m.className].addMethod(new _PotentialMethod2.default({
            name: m.methodName,
            methodNode: m.methodNode,
            fullNode: node,
            commentNodes: [node],
            parent: parent,
            static: true
          }));
        }
      } else if (m = (0, _matchPrototypeFunctionAssignment2.default)(node)) {
        if (potentialClasses[m.className]) {
          potentialClasses[m.className].addMethod(new _PotentialMethod2.default({
            name: m.methodName,
            methodNode: m.methodNode,
            fullNode: node,
            commentNodes: [node],
            parent: parent
          }));
        }
      } else if (m = (0, _matchPrototypeObjectAssignment2.default)(node)) {
        if (potentialClasses[m.className]) {
          m.methods.forEach(function (method, i) {
            var assignmentComments = i === 0 ? [node] : [];

            potentialClasses[m.className].addMethod(new _PotentialMethod2.default({
              name: method.methodName,
              methodNode: method.methodNode,
              fullNode: node,
              commentNodes: assignmentComments.concat([method.propertyNode]),
              parent: parent,
              kind: classMethodKind(method.kind)
            }));
          });
        }
      } else if (m = (0, _matchObjectDefinePropertyCall2.default)(node)) {
        if (potentialClasses[m.className]) {
          m.descriptors.forEach(function (desc, i) {
            var parentComments = i === 0 ? [node] : [];

            potentialClasses[m.className].addMethod(new _PotentialMethod2.default({
              name: m.methodName,
              methodNode: desc.methodNode,
              fullNode: node,
              commentNodes: parentComments.concat([desc.propertyNode]),
              parent: parent,
              kind: desc.kind
            }));
          });
        }
      } else if (m = inheritance.process(node, parent)) {
        if (potentialClasses[m.className]) {
          potentialClasses[m.className].setSuperClass(m.superClass, m.relatedExpressions);
        }
      }
    },
    leave: function leave(node) {
      if (node.type === 'Program') {
        (0, _fp.values)(potentialClasses).filter(function (cls) {
          return cls.isTransformable() ? true : logWarning(cls);
        }).forEach(function (cls) {
          return cls.transform();
        });
      }
    }
  });

  // Ordinary methods inside class use kind=method,
  // unlike methods inside object literal, which use kind=init.
  function classMethodKind(kind) {
    return kind === 'init' ? 'method' : kind;
  }

  function logWarning(cls) {
    if (/^[A-Z]/.test(cls.getName())) {
      logger.warn(cls.getFullNode(), 'Function ' + cls.getName() + ' looks like class, but has no prototype', 'class');
    }
  }
};

var _fp = require('lodash/fp');

var _traverser = require('../../traverser');

var _traverser2 = _interopRequireDefault(_traverser);

var _PotentialClass = require('./PotentialClass');

var _PotentialClass2 = _interopRequireDefault(_PotentialClass);

var _PotentialMethod = require('./PotentialMethod');

var _PotentialMethod2 = _interopRequireDefault(_PotentialMethod);

var _PotentialConstructor = require('./PotentialConstructor');

var _PotentialConstructor2 = _interopRequireDefault(_PotentialConstructor);

var _matchFunctionDeclaration = require('./matchFunctionDeclaration');

var _matchFunctionDeclaration2 = _interopRequireDefault(_matchFunctionDeclaration);

var _matchFunctionVar = require('./matchFunctionVar');

var _matchFunctionVar2 = _interopRequireDefault(_matchFunctionVar);

var _matchFunctionAssignment = require('./matchFunctionAssignment');

var _matchFunctionAssignment2 = _interopRequireDefault(_matchFunctionAssignment);

var _matchPrototypeFunctionAssignment = require('./matchPrototypeFunctionAssignment');

var _matchPrototypeFunctionAssignment2 = _interopRequireDefault(_matchPrototypeFunctionAssignment);

var _matchPrototypeObjectAssignment = require('./matchPrototypeObjectAssignment');

var _matchPrototypeObjectAssignment2 = _interopRequireDefault(_matchPrototypeObjectAssignment);

var _matchObjectDefinePropertyCall = require('./matchObjectDefinePropertyCall');

var _matchObjectDefinePropertyCall2 = _interopRequireDefault(_matchObjectDefinePropertyCall);

var _Inheritance = require('./inheritance/Inheritance');

var _Inheritance2 = _interopRequireDefault(_Inheritance);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }